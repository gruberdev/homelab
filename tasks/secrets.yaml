version: '3'
vars:
  CYAN: tput setaf 6
  RED: tput setaf 1
  YELLOW: tput setaf 3
  GREEN: tput setaf 2
  BLUE: tput setaf 1
  PURPLE: tput setaf 5
  BG_B: tput setab 0
  BOLD: tput bold
  RESET: tput sgr0
  CLEAR: tput reset
  PATH_ERROR: is not installed or correctly configured in PATH.

silent: true

tasks:
  n8n:
    cmds:
      - rm config/n8n-secret.yaml
      - |
        cat << EOF > config/n8n-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: n8n-vars
          namespace: services
        stringData:
          N8N_SMTP_HOST: "$SMTP_HOST"
          N8N_SMTP_PORT: "$SMTP_PORT"
          N8N_SMTP_USER: "$SMTP_USER"
          N8N_SMTP_PASS: "$SMTP_PASS"
          N8N_BASIC_AUTH_USER: "$N8N_BASIC_AUTH_USER"
          N8N_BASIC_AUTH_PASSWORD: "$N8N_BASIC_AUTH_PASSWORD"
          N8N_ENCRYPTION_KEY: "$N8N_ENCRYPTION_KEY"
          DB_POSTGRESDB_DATABASE: "$DB_POSTGRESDB_DATABASE"
          DB_POSTGRESDB_HOST: "$DB_POSTGRESDB_HOST"
          DB_POSTGRESDB_PORT: "$DB_POSTGRESDB_PORT"
        EOF
      - kubectl apply -f config/n8n-secret.yaml
      - rm config/n8n-secret.yaml
    ignore_error: true

  kuma:
    cmds:
      - rm config/kuma-secret.yaml
      - |
        cat << EOF > config/kuma-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: kuma-vars
          namespace: monitoring
        stringData:
          UPTIME_KUMA_CLOUDFLARED_TOKEN: "$UPTIME_KUMA_CLOUDFLARED_TOKEN"
        EOF
      - kubectl apply -f config/kuma-secret.yaml
      - rm config/kuma-secret.yaml
    ignore_error: true

  flame:
    cmds:
      - rm config/flame-secret.yaml
      - |
        cat << EOF > config/flame-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: flame-vars
          namespace: monitoring
        stringData:
          PASSWORD: "$FLAME_PASSWORD"
        EOF
      - kubectl apply -f config/flame-secret.yaml
      - rm config/flame-secret.yaml
    ignore_error: true

  poller:
    cmds:
      - rm config/poller-secret.yaml
      - |
        cat << EOF > config/poller-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: unifi-poller-vars
          namespace: unifi
        stringData:
          UP_UNIFI_DEFAULT_URL: "$UP_UNIFI_DEFAULT_URL"
          UP_UNIFI_DEFAULT_USER: "$UP_UNIFI_DEFAULT_USER"
          UP_UNIFI_DEFAULT_PASS: "$UP_UNIFI_DEFAULT_PASS"
        EOF
      - kubectl apply -f config/poller-secret.yaml
      - rm config/poller-secret.yaml
    ignore_error: true

  botkube:
    cmds:
      - rm config/botkube-secret.yaml
      - |
        cat << EOF > config/botkube-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: botkube-vars
          namespace: monitoring
        stringData:
          comm_config.yaml: |
            communications:
              'default-group':
                discord:
                  enabled: true
                  token: '$BOTKUBE_DISCORD_TOKEN'
                  botID: '$BOTKUBE_DISCORD_BOT_ID'
                  channels:
                    'kube-notifications':
                      id: '$BOTKUBE_DISCORD_CHANNEL_ID'
                      bindings:
                        executors:
                          - kubectl-read-only
                        sources:
                          - k8s-events
                  notification:
                    type: long
        EOF
      - kubectl apply -f config/botkube-secret.yaml
      - rm config/botkube-secret.yaml
    ignore_error: true

  kubeconfig:
    vars:
      KUBE:
        sh: cat $KUBECONFIG
    cmds:
      - rm config/kubeconfig-secret.yaml
      - |
        cat << EOF > config/kubeconfig-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: botkube-kubeconfig
          namespace: monitoring
        data:
          config: {{ .KUBE | b64enc }}
        EOF
      - kubectl apply -f config/kubeconfig-secret.yaml
      - rm config/kubeconfig-secret.yaml
    ignore_error: true

  wakapi:
    cmds:
      - rm config/wakapi-secret.yaml
      - |
        cat << EOF > config/wakapi-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: wakapi-vars
          namespace: services
        stringData:
          WAKAPI_PASSWORD_SALT: "$WAKAPI_PASSWORD_SALT"
          WAKAPI_DB_HOST: "$WAKAPI_DB_HOST"
          WAKAPI_DB_PORT: "$WAKAPI_DB_PORT"
          WAKAPI_DB_NAME: "$WAKAPI_DB_NAME"
          WAKAPI_MAIL_SENDER: "$WAKAPI_MAIL_SENDER"
          WAKAPI_MAIL_SMTP_HOST: "$SMTP_HOST"
          WAKAPI_MAIL_SMTP_PORT: "$SMTP_PORT"
          WAKAPI_MAIL_SMTP_USER: "$SMTP_USER"
          WAKAPI_MAIL_SMTP_PASS: "$SMTP_PASS"
        EOF
      - kubectl apply -f config/wakapi-secret.yaml
      - rm config/wakapi-secret.yaml
    ignore_error: true

  rss:gen:
    cmds:
      - rm config/rssgen-secret.yaml
      - |
        cat << EOF > config/rssgen-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: rssgen-vars
          namespace: rss
        stringData:
          TOKEN_SECRET: "$RSS_GEN_TOKEN_SECRET"
        EOF
      - kubectl apply -f config/rssgen-secret.yaml
      - rm config/rssgen-secret.yaml
    ignore_error: true

  rss:hub:
    cmds:
      - rm config/rsshub-secret.yaml
      - |
        cat << EOF > config/rsshub-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: rsshub-vars
          namespace: rss
        stringData:
          HTTP_BASIC_AUTH_NAME: "$RSS_HUB_USERNAME"
          HTTP_BASIC_AUTH_PASS: "$RSS_HUB_PASSWORD"
          ACCESS_KEY: "$RSS_HUB_ACCESSKEY"
          GITHUB_ACCESS_TOKEN: "$GH_PASS"
          GOOGLE_FONTS_API_KEY: "$GOOGLE_FONTS_API_KEY"
          IG_USERNAME: "$INSTAGRAM_USERNAME"
          IG_PASSWORD: "$INSTAGRAM_PASSWORD"
          IG_PROXY: "$INSTAGRAM_PROXY"
          LASTFM_API_KEY: "$LASTFM_API_KEY"
          SPOTIFY_CLIENT_ID: "$SPOTIFY_CLIENT_ID"
          SPOTIFY_REFRESHTOKEN: "$SPOTIFY_REFRESHTOKEN"
          YOUTUBE_KEY: "$YOUTUBE_KEY"
          YOUTUBE_CLIENT_ID: "$YOUTUBE_CLIENT_ID"
          YOUTUBE_CLIENT_SECRET: "$YOUTUBE_CLIENT_SECRET"
          YOUTUBE_REFRESH_TOKEN: "$YOUTUBE_REFRESH_TOKEN"
        EOF
      - kubectl apply -f config/rsshub-secret.yaml
      - rm config/rsshub-secret.yaml
    ignore_error: true

  wyze:
    cmds:
      - rm config/wyze-secret.yaml
      - |
        cat << EOF > config/wyze-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: wyze-vars
          namespace: homeassistant
        stringData:
          WYZE_EMAIL: "$WYZE_EMAIL"
          WYZE_PASSWORD: "$WYZE_PASSWORD"
          TOTP_KEY: "$WYZE_TOTP_KEY"
        EOF
      - kubectl apply -f config/wyze-secret.yaml
      - rm config/wyze-secret.yaml
    ignore_error: true

  metabase:
    cmds:
      - rm config/metabase-secret.yaml
      - |
        cat << EOF > config/metabase-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: metabase-vars
          namespace: services
        stringData:
          MB_DB_DBNAME: "$MB_DB_DBNAME"
          MB_DB_PORT: "$MB_DB_PORT"
          MB_DB_USER: "$MB_DB_USER"
          MB_DB_PASS: "$MB_DB_PASS"
          MB_ADMIN_EMAIL: "MB_ADMIN_EMAIL"
          MB_EMAIL_FROM_ADDRESS: "$MB_EMAIL_FROM_ADDRESS"
          MB_EMAIL_SMTP_HOST: "$SMTP_HOST"
          MB_EMAIL_SMTP_PASSWORD: "$SMTP_PASS"
          MB_EMAIL_SMTP_PORT: "$SMTP_PORT"
          MB_EMAIL_SMTP_USERNAME: "$SMTP_USER"
          MB_EMBEDDING_SECRET_KEY: "$MB_EMBEDDING_SECRET_KEY"
          MB_ENCRYPTION_SECRET_KEY: "$MB_ENCRYPTION_SECRET_KEY"
        EOF
      - kubectl apply -f config/metabase-secret.yaml
      - rm config/metabase-secret.yaml
    ignore_error: true

  argocd:
    cmds:
      - |
        PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo) \
        argocd login --insecure --username admin --password ${PASSWORD} $ARGOCD_URI
      - argocd account generate-token --account image-updater --id image-updater > config/argo-token.yaml

  argocd:setup:
    - |
      PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo) \
      argocd login --insecure --username admin --password ${PASSWORD} $ARGOCD_URI
    - argocd account update-password

  image-updater:
    vars:
      ARGOCD_TOKEN:
        sh: cat config/argo-token.yaml
    cmds:
      - rm config/argo-secret.yaml
      - |
        cat << EOF > config/argo-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: argocd-image-updater-secret
          namespace: argocd
          labels:
            app.kubernetes.io/name: argocd-image-updater-secret
            app.kubernetes.io/part-of: argocd-image-updater
        type: Opaque
        data:
          argocd.token:  "{{ .ARGOCD_TOKEN | b64enc }}"
        EOF
      - kubectl apply -f config/argo-secret.yaml
      - kubectl -n argocd rollout restart deployment argocd-image-updater
      - rm config/argo-secret.yaml
      - rm test-argo-token.yaml
    ignore_error: true

  ha:
    cmds:
      - rm config/ha-secret.yaml
      - |
        cat << EOF > config/ha-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: ha-secrets
          namespace: homeassistant
        type: Opaque
        stringData:
          secrets.yaml: |
            server_address: $INTERNAL_IPV4
            public_ip: $EXTERNAL_IPV4

            # Samsung
            #tv_ipv4: $SAMSUNG_IPV4
            #tv_mac: $SAMSUNG_MAC
            # Steam
            steam_api_key: $STEAM_API_KEY
            # LastFM
            lastfm_api_key: $LASTFM_API_KEY
            # IFTTT Integration
            #ifttt_api_key: $IFTTT_API_KEY
            # Twitch
            twitch_client_id: $TWITCH_CLIENT_ID
            twitch_client_secret: $TWITCH_CLIENT_SECRET
            twitch_token: $TWITCH_CLIENT_TOKEN

            # Vultr
            vultr_api_key: $VULTR_API_KEY
            # Sonarr
            sonarr_api_key: $SONARR_API_KEY
            # Unifi
            unifi_host: $UNIFI_IPV4
            unifi_password: $UNIFI_PASSWORD
            # iCloud3
            icloud_username: $ICLOUD_USERNAME
            icloud_password: $ICLOUD_PASSWORD

            # Alpha Vantage Exchange Integration
            alpha_vantage_api_key: $ALPHA_API_KEY
            # PostgreSQL Database
            external_database: $DB_STRING

            ha_latitude:  $HA_LATITUDE
            ha_longitude: $HA_LONGITUDE
            ha_elevation: $HA_ELEVATION

            # Accuweather Integration
            accuweather_api_key: $ACCUWEATHER_API_KEY
            # OpenWeatherMap Integration
            openweathermap_api_key: $OPENWEATHERMAP_API_KEY

            # Apex Charts Integration
            apexcharts_tibber: ""
            apexcharts_influx: ""
            apexcharts_github: ""

            youtube_token: ""

            # SMTP Integration
            smtp_server: $SMTP_HOST
            smtp_sender: $HA_SENDER_EMAIL
            smtp_username: $SMTP_USER
            smtp_password: $SMTP_PASS
            smtp_recipient1: $HA_RECIPIENT_EMAIL_1
            smtp_recipient2: $HA_RECIPIENT_EMAIL_2
        EOF
      - kubectl apply -f config/ha-secret.yaml
      - rm config/ha-secret.yaml
    ignore_error: true

  infra:
    cmds:
      - rm config/infra-secret.yaml
      - |
        cat << EOF > config/infra-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: infra-admin-credentials
          namespace: kube-system
        type: Opaque
        stringData:
          INFRA_ADMIN_PASSWORD: "$INFRA_ADMIN_PASSWORD"
          INFRA_CLUSTER_IP: "$INFRA_CLUSTER_IP"
          INFRA_ADMIN_KEY: "$INFRA_ADMIN_KEY"
          INFRA_ADMIN_USERNAME: "$INFRA_ADMIN_USERNAME"
        EOF
      - kubectl apply -f config/infra-secret.yaml
      - rm config/infra-secret.yaml
    ignore_error: true

  aws:
    cmds:
      - rm config/aws-secret.yaml
      - |
        cat << EOF > config/aws-secret.yaml
        apiVersion: v1
        apiVersion: v1
        kind: Secret
        metadata:
          name: aws-secret
          namespace: kube-system
        stringData:
          key_id: "$AWS_KEY_ID"
          access_key: "$AWS_SECRET_KEY"
        EOF
      - kubectl apply -f config/aws-secret.yaml
      - rm config/aws-secret.yaml
    ignore_error: true

  digitalocean:
    cmds:
      - rm config/digitalocean-secret.yaml
      - |
        cat << EOF > config/digitalocean-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: digitalocean
          namespace: kube-system
        stringData:
          access-token: "$DIGITALOCEAN_ACCESS_TOKEN"
        EOF
      - kubectl apply -f config/digitalocean-secret.yaml
      - rm config/digitalocean-secret.yaml
    ignore_error: true

  vultr:
    cmds:
      - rm config/vultr-secret.yaml
      - |
        cat << EOF > config/vultr-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: vultr-csi
          namespace: kube-system
        stringData:
          # Replace the api-key with a proper value
          api-key: "$VULTR_API_KEY"
        EOF
      - kubectl apply -f config/vultr-secret.yaml
      - rm config/vultr-secret.yaml
    ignore_error: true

  ssh:
    cmds:
      - rm config/git-secret.yaml
      - |
        cat << EOF > config/git-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: git-vars
          namespace: homeassistant
        stringData:
          GIT_SYNC_SSH_KNOWN_HOSTS_FILE: "$SSH_KNOWN_HOSTS"
          GIT_SYNC_SSH_KEY_FILE: "$SSH_KEY_FILE"
        EOF
      - kubectl apply -f config/git-secret.yaml
      - rm config/git-secret.yaml
      - kubectl create secret generic ssh-key --from-file=id_ed25519=id_ed25519 -n homeassistant
      - kubectl create secret generic known-hosts --from-file=known_hosts=known_hosts -n homeassistant
    ignore_error: true

  gen:
    cmds:
      - task: kuma
      - task: botkube
      - task: kubeconfig
      - task: rss:gen
      - task: rss:hub
      - task: metabase
      - task: ha
      - task: infra
      - task: ssh
