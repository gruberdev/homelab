apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: vault
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: apps
  source:
    repoURL: https://github.com/hashicorp/vault-helm.git
    targetRevision: main
    path: .
    helm:
      releaseName: vault
      values: |
        global:
          enabled: true
          imagePullSecrets: []
          tlsDisable: true
          openshift: false
          psp:
            enable: false
            annotations: |
              seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default,runtime/default
              apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default
              seccomp.security.alpha.kubernetes.io/defaultProfileName:  runtime/default
              apparmor.security.beta.kubernetes.io/defaultProfileName:  runtime/default
        injector:
          enabled: true
          replicas: 1
          port: 8080
          leaderElector:
            enabled: true
          metrics:
            enabled: false
          externalVaultAddr: ""
          image:
            repository: "hashicorp/vault-k8s"
            tag: "0.17.0"
            pullPolicy: IfNotPresent
          agentImage:
            repository: "hashicorp/vault"
            tag: "1.11.2"
          agentDefaults:
            cpuLimit: "350m"
            cpuRequest: "250m"
            memLimit: "128Mi"
            memRequest: "64Mi"
            template: "map"
          templateConfig:
              exitOnRetryFailure: true
              staticSecretRenderInterval: ""
          authPath: "auth/kubernetes"
          logLevel: "info"
          logFormat: "standard"
          revokeOnShutdown: false
          namespaceSelector: {}
          objectSelector: {}
          failurePolicy: Ignore
          webhookAnnotations: {}
          certs:
            secretName: null
            caBundle: ""
            certName: tls.crt
            keyName: tls.key

          resources:
            requests:
              memory: 256Mi
              cpu: 250m
            limits:
              memory: 256Mi
              cpu: 250m
          extraEnvironmentVars: {}
          affinity: |
            podAntiAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                - labelSelector:
                    matchLabels:
                      app.kubernetes.io/name: {{ template "vault.name" . }}-agent-injector
                      app.kubernetes.io/instance: "{{ .Release.Name }}"
                      component: webhook
                  topologyKey: kubernetes.io/hostname
          tolerations: []
          nodeSelector: {}
          priorityClassName: ""
          annotations: {}
          extraLabels: {}
          hostNetwork: false
          service:
            annotations: {}
          podDisruptionBudget: {}
        strategy:
          type: Recreate
        server:
          enabled: true
          image:
            repository: "hashicorp/vault"
            tag: "1.11.2"
            pullPolicy: IfNotPresent

          updateStrategyType: "OnDelete"
          logLevel: ""

          # Configure the logging format for the Vault server.
          # Supported log formats include: standard, json
          logFormat: ""

          resources:
            requests:
              memory: 256Mi
              cpu: 250m
            limits:
              memory: 512Mi
              cpu: 350m

          # Ingress allows ingress services to be created to allow external access
          # from Kubernetes to access Vault pods.
          # If deployment is on OpenShift, the following block is ignored.
          # In order to expose the service, use the route section below
          ingress:
            enabled: false
            labels: {}
            annotations: {}
            ingressClassName: "nginx"
            pathType: Prefix
            activeService: true
            hosts:
            - host: vault.k8s.localhost
              http:
                paths:
                - backend:
                    service:
                      name: vault
                      port:
                        number: 8200
                  path: /
                  pathType: Prefix
            extraPaths: []
            tls:
            - hosts:
              - vault.k8s.localhost
              secretName: tls-secret
          # OpenShift only - create a route to expose the service
          # The created route will be of type passthrough
          route:
            enabled: false

            # When HA mode is enabled and K8s service registration is being used,
            # configure the route to point to the Vault active service.
            activeService: true

            labels: {}
            annotations: {}
            host: chart-example.local

          # authDelegator enables a cluster role binding to be attached to the service
          # account.  This cluster role binding can be used to setup Kubernetes auth
          # method.  https://www.vaultproject.io/docs/auth/kubernetes.html
          authDelegator:
            enabled: true

          # extraInitContainers is a list of init containers. Specified as a YAML list.
          # This is useful if you need to run a script to provision TLS certificates or
          # write out configuration files in a dynamic way.
          extraInitContainers: null
            # # This example installs a plugin pulled from github into the /usr/local/libexec/vault/oauthapp folder,
            # # which is defined in the volumes value.
            # - name: oauthapp
            #   image: "alpine"
            #   command: [sh, -c]
            #   args:
            #     - cd /tmp &&
            #       wget https://github.com/puppetlabs/vault-plugin-secrets-oauthapp/releases/download/v1.2.0/vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64.tar.xz -O oauthapp.xz &&
            #       tar -xf oauthapp.xz &&
            #       mv vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64 /usr/local/libexec/vault/oauthapp &&
            #       chmod +x /usr/local/libexec/vault/oauthapp
            #   volumeMounts:
            #     - name: plugins
            #       mountPath: /usr/local/libexec/vault

          # extraContainers is a list of sidecar containers. Specified as a YAML list.
          extraContainers: []

          # shareProcessNamespace enables process namespace sharing between Vault and the extraContainers
          # This is useful if Vault must be signaled, e.g. to send a SIGHUP for log rotation
          shareProcessNamespace: true

          # extraArgs is a string containing additional Vault server arguments.
          extraArgs: ""

          # Used to define custom readinessProbe settings
          readinessProbe:
            enabled: true
            # If you need to use a http path instead of the default exec
            # path: /v1/sys/health?standbyok=true

            # When a probe fails, Kubernetes will try failureThreshold times before giving up
            failureThreshold: 2
            # Number of seconds after the container has started before probe initiates
            initialDelaySeconds: 30
            # How often (in seconds) to perform the probe
            periodSeconds: 15
            # Minimum consecutive successes for the probe to be considered successful after having failed
            successThreshold: 1
            # Number of seconds after which the probe times out.
            timeoutSeconds: 5
          # Used to enable a livenessProbe for the pods
          livenessProbe:
            enabled: false
            path: "/v1/sys/health?standbyok=true"
            # When a probe fails, Kubernetes will try failureThreshold times before giving up
            failureThreshold: 3
            # Number of seconds after the container has started before probe initiates
            initialDelaySeconds: 120
            # How often (in seconds) to perform the probe
            periodSeconds: 10
            # Minimum consecutive successes for the probe to be considered successful after having failed
            successThreshold: 1
            # Number of seconds after which the probe times out.
            timeoutSeconds: 5

          # Optional duration in seconds the pod needs to terminate gracefully.
          # See: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
          terminationGracePeriodSeconds: 60

          # Used to set the sleep time during the preStop step
          preStopSleepSeconds: 5

          # Used to define commands to run after the pod is ready.
          # This can be used to automate processes such as initialization
          # or boostrapping auth methods.
          postStart: []
          # - /bin/sh
          # - -c
          # - /vault/userconfig/myscript/run.sh

          # extraEnvironmentVars is a list of extra environment variables to set with the stateful set. These could be
          # used to include variables required for auto-unseal.
          extraEnvironmentVars: {}
          extraSecretEnvironmentVars: []


          # Deprecated: please use 'volumes' instead.
          # extraVolumes is a list of extra volumes to mount. These will be exposed
          # to Vault in the path `/vault/userconfig/<name>/`. The value below is
          # an array of objects, examples are shown below.
          extraVolumes: []
            # - type: secret (or "configMap")
            #   name: my-secret
            #   path: null # default is `/vault/userconfig`

          # volumes is a list of volumes made available to all containers. These are rendered
          # via toYaml rather than pre-processed like the extraVolumes value.
          # The purpose is to make it easy to share volumes between containers.
          volumes: null
          #   - name: plugins
          #     emptyDir: {}

          # volumeMounts is a list of volumeMounts for the main server container. These are rendered
          # via toYaml rather than pre-processed like the extraVolumes value.
          # The purpose is to make it easy to share volumes between containers.
          volumeMounts: null
          #   - mountPath: /usr/local/libexec/vault
          #     name: plugins
          #     readOnly: true

          # Affinity Settings
          # Commenting out or setting as empty the affinity variable, will allow
          # deployment to single node services such as Minikube
          # This should be either a multi-line string or YAML matching the PodSpec's affinity field.
          affinity: |
            podAntiAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                - labelSelector:
                    matchLabels:
                      app.kubernetes.io/name: {{ template "vault.name" . }}
                      app.kubernetes.io/instance: "{{ .Release.Name }}"
                      component: server
                  topologyKey: kubernetes.io/hostname
          # Toleration Settings for server pods
          # This should be either a multi-line string or YAML matching the Toleration array
          # in a PodSpec.
          tolerations: []

          # nodeSelector labels for server pod assignment, formatted as a multi-line string or YAML map.
          # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
          # Example:
          # nodeSelector:
          #   beta.kubernetes.io/arch: amd64
          nodeSelector: {}

          # Enables network policy for server pods
          networkPolicy:
            enabled: false
            egress: []
            # egress:
            # - to:
            #   - ipBlock:
            #       cidr: 10.0.0.0/24
            #   ports:
            #   - protocol: TCP
            #     port: 443

          # Priority class for server pods
          priorityClassName: ""

          # Extra labels to attach to the server pods
          # This should be a YAML map of the labels to apply to the server pods
          extraLabels: {}

          # Extra annotations to attach to the server pods
          # This can either be YAML or a YAML-formatted multi-line templated string map
          # of the annotations to apply to the server pods
          annotations: {}

          # Enables a headless service to be used by the Vault Statefulset
          service:
            enabled: true
            type: ClusterIP

            # The externalTrafficPolicy can be set to either Cluster or Local
            # and is only valid for LoadBalancer and NodePort service types.
            # The default value is Cluster.
            # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy
            externalTrafficPolicy: Cluster
            port: 8200
            targetPort: 8200
            annotations: {}
          dataStorage:
            enabled: true
            size: 5Gi
            mountPath: "/vault/data"
            storageClass: longhorn
            accessMode: ReadWriteMany
            annotations: {}

          # This configures the Vault Statefulset to create a PVC for audit
          # logs.  Once Vault is deployed, initialized and unseal, Vault must
          # be configured to use this for audit logs.  This will be mounted to
          # /vault/audit
          # See https://www.vaultproject.io/docs/audit/index.html to know more
          auditStorage:
            enabled: false
            # Size of the PVC created
            size: 1Gi
            # Location where the PVC will be mounted.
            mountPath: "/vault/audit"
            # Name of the storage class to use.  If null it will use the
            # configured default Storage Class.
            storageClass: null
            # Access Mode of the storage device being used for the PVC
            accessMode: ReadWriteMany
            # Annotations to apply to the PVC
            annotations: {}

          dev:
            enabled: false

            # Set VAULT_DEV_ROOT_TOKEN_ID value
            devRootToken: "root"

          # Run Vault in "standalone" mode. This is the default mode that will deploy if
          # no arguments are given to helm. This requires a PVC for data storage to use
          # the "file" backend.  This mode is not highly available and should not be scaled
          # past a single replica.
          standalone:
            enabled: "-"

            # config is a raw string of default configuration when using a Stateful
            # deployment. Default is to use a PersistentVolumeClaim mounted at /vault/data
            # and store data there. This is only used when using a Replica count of 1, and
            # using a stateful set. This should be HCL.

            # Note: Configuration files are stored in ConfigMaps so sensitive data
            # such as passwords should be either mounted through extraSecretEnvironmentVars
            # or through a Kube secret.  For more information see:
            # https://www.vaultproject.io/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations
            config: |
              ui = true
              listener "tcp" {
                tls_disable = 1
                address = "[::]:8200"
                cluster_address = "[::]:8201"
              }
              storage "file" {
                path = "/vault/data"
              }
              # Example configuration for using auto-unseal, using Google Cloud KMS. The
              # GKMS keys must already exist, and the cluster must have a service account
              # that is authorized to access GCP KMS.
              #seal "gcpckms" {
              #   project     = "vault-helm-dev"
              #   region      = "global"
              #   key_ring    = "vault-helm-unseal-kr"
              #   crypto_key  = "vault-helm-unseal-key"
              #}
          # Run Vault in "HA" mode. There are no storage requirements unless audit log
          # persistence is required.  In HA mode Vault will configure itself to use Consul
          # for its storage backend.  The default configuration provided will work the Consul
          # Helm project by default.  It is possible to manually configure Vault to use a
          # different HA backend.
          ha:
            enabled: false
            replicas: 3

            # Set the api_addr configuration for Vault HA
            # See https://www.vaultproject.io/docs/configuration#api_addr
            # If set to null, this will be set to the Pod IP Address
            apiAddr: null

            # Enables Vault's integrated Raft storage.  Unlike the typical HA modes where
            # Vault's persistence is external (such as Consul), enabling Raft mode will create
            # persistent volumes for Vault to store data according to the configuration under server.dataStorage.
            # The Vault cluster will coordinate leader elections and failovers internally.
            raft:

              # Enables Raft integrated storage
              enabled: false
              # Set the Node Raft ID to the name of the pod
              setNodeId: false

              # Note: Configuration files are stored in ConfigMaps so sensitive data
              # such as passwords should be either mounted through extraSecretEnvironmentVars
              # or through a Kube secret.  For more information see:
              # https://www.vaultproject.io/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations
              config: |
                ui = true
                listener "tcp" {
                  tls_disable = 1
                  address = "[::]:8200"
                  cluster_address = "[::]:8201"
                }
                storage "raft" {
                  path = "/vault/data"
                }
                service_registration "kubernetes" {}
            # config is a raw string of default configuration when using a Stateful
            # deployment. Default is to use a Consul for its HA storage backend.
            # This should be HCL.

            # Note: Configuration files are stored in ConfigMaps so sensitive data
            # such as passwords should be either mounted through extraSecretEnvironmentVars
            # or through a Kube secret.  For more information see:
            # https://www.vaultproject.io/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations
            config: |
              ui = true
              listener "tcp" {
                tls_disable = 1
                address = "[::]:8200"
                cluster_address = "[::]:8201"
              }
              storage "consul" {
                path = "vault"
                address = "HOST_IP:8500"
              }
              service_registration "kubernetes" {}
              # Example configuration for using auto-unseal, using Google Cloud KMS. The
              # GKMS keys must already exist, and the cluster must have a service account
              # that is authorized to access GCP KMS.
              #seal "gcpckms" {
              #   project     = "vault-helm-dev-246514"
              #   region      = "global"
              #   key_ring    = "vault-helm-unseal-kr"
              #   crypto_key  = "vault-helm-unseal-key"
              #}
            # A disruption budget limits the number of pods of a replicated application
            # that are down simultaneously from voluntary disruptions
            disruptionBudget:
              enabled: true

            # maxUnavailable will default to (n/2)-1 where n is the number of
            # replicas. If you'd like a custom value, you can specify an override here.
              maxUnavailable: null

          # Definition of the serviceAccount used to run Vault.
          # These options are also used when using an external Vault server to validate
          # Kubernetes tokens.
          serviceAccount:
            # Specifies whether a service account should be created
            create: true
            # The name of the service account to use.
            # If not set and create is true, a name is generated using the fullname template
            name: ""
            # Extra annotations for the serviceAccount definition. This can either be
            # YAML or a YAML-formatted multi-line templated string map of the
            # annotations to apply to the serviceAccount.
            annotations: {}

          # Settings for the statefulSet used to run Vault.
          statefulSet:
            # Extra annotations for the statefulSet. This can either be YAML or a
            # YAML-formatted multi-line templated string map of the annotations to apply
            # to the statefulSet.
            annotations: {}

        # Vault UI
        ui:
          enabled: true
          publishNotReadyAddresses: true
          activeVaultPodOnly: false
          serviceType: "ClusterIP"
          serviceNodePort: null
          externalPort: 8200
          targetPort: 8200
          # The externalTrafficPolicy can be set to either Cluster or Local
          # and is only valid for LoadBalancer and NodePort service types.
          # The default value is Cluster.
          # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy
          externalTrafficPolicy: Cluster

          #loadBalancerSourceRanges:
          #   - 10.0.0.0/16
          #   - 1.78.23.3/32

          # loadBalancerIP:

          # Extra annotations to attach to the ui service
          # This can either be YAML or a YAML-formatted multi-line templated string map
          # of the annotations to apply to the ui service
          annotations: {}

        # secrets-store-csi-driver-provider-vault
        csi:
          # True if you want to install a secrets-store-csi-driver-provider-vault daemonset.
          #
          # Requires installing the secrets-store-csi-driver separately, see:
          # https://github.com/kubernetes-sigs/secrets-store-csi-driver#install-the-secrets-store-csi-driver
          #
          # With the driver and provider installed, you can mount Vault secrets into volumes
          # similar to the Vault Agent injector, and you can also sync those secrets into
          # Kubernetes secrets.
          enabled: false

          image:
            repository: "hashicorp/vault-csi-provider"
            tag: "0.3.0"
            pullPolicy: IfNotPresent

          # volumes is a list of volumes made available to all containers. These are rendered
          # via toYaml rather than pre-processed like the extraVolumes value.
          # The purpose is to make it easy to share volumes between containers.
          volumes: null
          # - name: tls
          #   secret:
          #     secretName: vault-tls

          # volumeMounts is a list of volumeMounts for the main server container. These are rendered
          # via toYaml rather than pre-processed like the extraVolumes value.
          # The purpose is to make it easy to share volumes between containers.
          volumeMounts: null
          # - name: tls
          #   mountPath: "/vault/tls"
          #   readOnly: true

          resources:
          # resources:
          #   requests:
          #     cpu: 50m
          #     memory: 128Mi
          #   limits:
          #     cpu: 50m
          #     memory: 128Mi

          # Settings for the daemonSet used to run the provider.
          daemonSet:
            updateStrategy:
              type: RollingUpdate
              maxUnavailable: ""
            # Extra annotations for the daemonSet. This can either be YAML or a
            # YAML-formatted multi-line templated string map of the annotations to apply
            # to the daemonSet.
            annotations: {}
            # Provider host path (must match the CSI provider's path)
            providersDir: "/etc/kubernetes/secrets-store-csi-providers"
            # Kubelet host path
            kubeletRootDir: "/var/lib/kubelet"

          pod:
            # Extra annotations for the provider pods. This can either be YAML or a
            # YAML-formatted multi-line templated string map of the annotations to apply
            # to the pod.
            annotations: {}

            # Toleration Settings for provider pods
            # This should be either a multi-line string or YAML matching the Toleration array
            # in a PodSpec.
            tolerations: []

          # Priority class for csi pods
          priorityClassName: ""

          serviceAccount:
            # Extra annotations for the serviceAccount definition. This can either be
            # YAML or a YAML-formatted multi-line templated string map of the
            # annotations to apply to the serviceAccount.
            annotations: {}

          # Used to configure readinessProbe for the pods.
          readinessProbe:
            # When a probe fails, Kubernetes will try failureThreshold times before giving up
            failureThreshold: 2
            # Number of seconds after the container has started before probe initiates
            initialDelaySeconds: 15
            # How often (in seconds) to perform the probe
            periodSeconds: 5
            # Minimum consecutive successes for the probe to be considered successful after having failed
            successThreshold: 1
            # Number of seconds after which the probe times out.
            timeoutSeconds: 3
          # Used to configure livenessProbe for the pods.
          livenessProbe:
            # When a probe fails, Kubernetes will try failureThreshold times before giving up
            failureThreshold: 3
            # Number of seconds after the container has started before probe initiates
            initialDelaySeconds: 60
            # How often (in seconds) to perform the probe
            periodSeconds: 15
            # Minimum consecutive successes for the probe to be considered successful after having failed
            successThreshold: 1
            # Number of seconds after which the probe times out.
            timeoutSeconds: 5

          # Enables debug logging.
          debug: false

          # Pass arbitrary additional arguments to vault-csi-provider.
          extraArgs: []

  destination:
    namespace: vault
    name: in-cluster
  syncPolicy:
    automated:
      prune: true
      selfHeal: false
      allowEmpty: true
    syncOptions:
    - Validate=false
    - CreateNamespace=true
    - PrunePropagationPolicy=foreground
    - PruneLast=true
    - ApplyOutOfSyncOnly=false
    - Prune=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
